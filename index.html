<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
    <script src="user_config.js"></script>
    <title>Music Galaxy</title>
    <script>
        document.title = typeof CONFIG !== 'undefined' ? CONFIG.pageTitle : "Music Galaxy";
    </script>
    <style>
        /* === RESET & BASE (From 22DecTry) === */
        body {
            margin: 0;
            background: #000;
            color: white;
            font-family: 'Helvetica Neue', sans-serif;
            overflow: hidden;
        }

        #canvas {
            display: block;
            cursor: grab;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #canvas:active {
            cursor: grabbing;
        }

        /* === UI OVERLAYS (From 22DecTry) === */
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            mix-blend-mode: difference;
            z-index: 20;
        }

        /* JOURNEY PANEL (From 22DecTry) */
        #journey-panel {
            position: absolute;
            top: 150px;
            left: 20px;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 50;
        }

        .journey-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            font-size: 0.9em;
            transition: all 0.2s;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .journey-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateX(5px);
        }

        #auto-btn {
            border-color: #00ffff;
            color: #00ffff;
            background: rgba(0, 255, 255, 0.1);
            display: none;
        }

        #skip-btn {
            border-color: #ffaa00;
            color: #ffaa00;
            background: rgba(255, 170, 0, 0.1);
            display: none;
        }

        /* === ADMIN PANEL STYLES (From index.html) === */
        #admin-panel {
            position: absolute;
            top: 0;
            right: 0;
            width: 350px;
            height: 100%;
            background: #0d1117;
            border-left: 1px solid #30363d;
            transform: translateX(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            z-index: 100;
        }

        #admin-panel.open {
            transform: translateX(0);
        }

        .admin-content {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .admin-section {
            margin-bottom: 25px;
        }

        .admin-label {
            display: block;
            font-size: 0.75em;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #8b949e;
            margin-bottom: 8px;
            font-weight: bold;
        }

        textarea.code-box {
            width: 100%;
            height: 80px;
            background: #000;
            border: 1px solid #30363d;
            color: #00ff88;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 11px;
            padding: 10px;
            box-sizing: border-box;
            resize: vertical;
            border-radius: 6px;
        }

        .btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            font-size: 0.9em;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .btn-primary {
            background: #0088ff;
            border-color: #0088ff;
        }

        .btn-primary:hover {
            background: #0099ff;
        }

        .btn-danger {
            background: rgba(255, 50, 50, 0.2);
            border-color: #ff3333;
            color: #ffcccc;
        }

        .bookmarklet-btn {
            display: block;
            background: #238636;
            color: white;
            text-align: center;
            padding: 12px;
            border-radius: 6px;
            font-weight: bold;
            text-decoration: none;
            border: 1px dashed rgba(255, 255, 255, 0.4);
            cursor: move;
        }

        /* === PLAYER UI (From 22DecTry + index.html tweaks) === */
        #now-playing {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            background: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 15px 25px;
            border-radius: 30px;
            display: none;
            text-align: center;
            z-index: 90;
        }

        #np-title {
            font-weight: 700;
            font-size: 1.1em;
            color: #fff;
            margin-bottom: 5px;
        }

        #video-dock {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 320px;
            height: 180px;
            background: #000;
            border: 2px solid #333;
            border-radius: 12px;
            overflow: hidden;
            z-index: 100;
            display: none;
            transition: all 0.4s;
        }

        #video-dock:hover {
            width: 640px;
            height: 360px;
            border-color: white;
            transform: translate(-20px, -20px);
        }

        #yt-player-wrapper {
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #video-dock:hover #yt-player-wrapper {
            pointer-events: auto;
        }

        /* === PLACARD UI === */
        #placard-overlay {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            max-width: 600px;
            width: 80%;
            background: rgba(15, 20, 25, 0.95);
            border: 2px solid #536DFE;
            box-shadow: 0 0 20px rgba(83, 109, 254, 0.4), inset 0 0 10px rgba(0, 0, 0, 0.8);
            border-radius: 12px;
            padding: 20px 30px;
            color: #fff;
            z-index: 85;
            /* Below now-playing */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease, transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: flex;
            flex-direction: column;
            gap: 10px;
            text-align: center;
        }

        #placard-overlay.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            pointer-events: auto;
        }

        #placard-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            color: #00E5FF;
            margin: 0;
            text-shadow: 2px 2px 0 #000;
            text-transform: uppercase;
        }

        #placard-desc {
            font-family: 'Helvetica Neue', sans-serif;
            font-size: 15px;
            line-height: 1.6;
            color: #ddd;
            margin: 0;
            white-space: pre-wrap;
        }

        /* === START SCREEN === */
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
        }

        #start-btn {
            padding: 15px 40px;
            font-size: 1.2em;
            cursor: pointer;
            border-radius: 50px;
            font-weight: bold;
            border: none;
        }
    </style>
    <!-- === GOOGLE FONTS (Retro) === -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* ... existing styles ... */

        /* === GAMIFIED INTRO CSS === */
        #intro-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a0b2e 0%, #000000 100%);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Press Start 2P', cursive;
        }

        #intro-scene {
            width: 80%;
            max-width: 800px;
            height: 70%;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
        }

        /* Professor/Guide Character */
        #guide-char {
            width: 250px;
            height: 250px;
            background-repeat: no-repeat;
            background-position: center bottom;
            background-size: contain;
            image-rendering: pixelated;
            margin-bottom: 20px;
            filter: drop-shadow(0 0 10px white);
        }

        /* Dialogue Box */
        #dialogue-box {
            width: 100%;
            background: #fff;
            border: 4px solid #333;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 8px 8px 0 #222;
            position: relative;
            min-height: 150px;
        }

        #dialogue-text {
            color: #000;
            font-size: 14px;
            line-height: 1.8;
            margin: 0;
            white-space: pre-wrap;
        }

        #next-arrow {
            position: absolute;
            bottom: 10px;
            right: 15px;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid #f00;
            animation: bounce 0.8s infinite;
            cursor: pointer;
            display: none;
        }

        @keyframes bounce {
            0% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(5px);
            }

            100% {
                transform: translateY(0);
            }
        }

        /* Skip Button */
        #skip-btn-intro {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: transparent;
            color: #666;
            border: none;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
        }

        #skip-btn-intro:hover {
            color: #fff;
        }

        /* Actions Container */
        #intro-actions {
            margin-top: 15px;
            display: none;
            gap: 10px;
            justify-content: center;
            width: 100%;
        }

        .action-btn {
            background: #238636;
            color: white;
            border: 2px solid #000;
            padding: 10px 15px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            cursor: pointer;
            box-shadow: 4px 4px 0 #000;
        }

        .action-btn:hover {
            transform: translateY(2px);
            box-shadow: 2px 2px 0 #000;
        }

        .action-btn.secondary {
            background: #0088ff;
        }

        #avatar-upload {
            display: none;
        }

        /* CREDITS MODAL */
        #credits-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2500;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #credits-box {
            width: 80%;
            max-width: 600px;
            background: #fff;
            border: 4px solid #333;
            box-shadow: 8px 8px 0 #222;
            padding: 20px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        #credits-content {
            flex: 1;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            /* Monospace for alignment */
            font-size: 12px;
            white-space: pre-wrap;
            color: #000;
            margin-bottom: 20px;
            border: 1px solid #ccc;
            /* Inner border */
            padding: 10px;
        }

        #credits-close-btn {
            align-self: flex-end;
            background: #ff4444;
            color: white;
            border: 2px solid #000;
            padding: 10px 20px;
            font-family: 'Press Start 2P', cursive;
            cursor: pointer;
            box-shadow: 4px 4px 0 #000;
        }

        #credits-close-btn:hover {
            transform: translateY(2px);
            box-shadow: 2px 2px 0 #000;
        }
    </style>
</head>

<body>

    <!-- === CREDITS MODAL === -->
    <div id="credits-modal">
        <div id="credits-box">
            <h3 style="font-family: 'Press Start 2P'; margin-top: 0;">CREDITS</h3>
            <div id="credits-content">Loading...</div>
            <button id="credits-close-btn" onclick="closeCredits()">CLOSE</button>
        </div>
    </div>

    <!-- === GAMIFIED INTRO LAYER === -->
    <div id="intro-layer">
        <div id="intro-scene">
            <div id="guide-char"></div>
            <div id="dialogue-box">
                <p id="dialogue-text"></p>
                <div id="next-arrow" onclick="nextIntroStep()"></div>

                <!-- Action Buttons (Hidden by default) -->
                <div id="intro-actions">
                    <button class="action-btn" id="act-btn-1">YES</button>
                    <button class="action-btn secondary" id="act-btn-2">NO</button>
                </div>
            </div>
        </div>

        <!-- Top Right Credits -->
        <button id="credits-btn-intro" onclick="showCredits()"
            style="position: absolute; top: 20px; right: 20px; background: transparent; color: #666; border: none; font-family: 'Press Start 2P', cursive; font-size: 10px; cursor: pointer; z-index: 2001;">[CREDITS]</button>

        <!-- Bottom Right Skip -->
        <button id="skip-btn-intro" onclick="endIntro()"
            style="position: absolute; bottom: 20px; right: 20px; background: transparent; color: #666; border: none; font-family: 'Press Start 2P', cursive; font-size: 10px; cursor: pointer;">[SKIP
            INTRO]</button>

        <!-- Original Creator Attribution -->
        <a href="https://github.com/munir-paviwala/musicForAll" target="_blank"
            style="position: absolute; bottom: 20px; left: 20px; color: #444; text-decoration: none; font-family: 'Press Start 2P', cursive; font-size: 8px; z-index: 2000; text-transform: uppercase;">Original
            Engine by Munir Paviwala</a>

        <!-- Make Your Own Galaxy -->
        <a href="setup.html"
            style="position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); color: #00E5FF; text-decoration: none; font-family: 'Press Start 2P', cursive; font-size: 10px; z-index: 2000; text-transform: uppercase; border: 1px dashed #00E5FF; padding: 5px 10px; background: rgba(0,229,255,0.1);">
            ‚ú® Make Your Own Galaxy ‚ú®
        </a>
    </div>

    <!-- Hidden Avatar Input -->
    <input type="file" id="avatar-upload" accept="image/*">

    <!-- === MAIN CANVAS (Hidden initially) === -->
    <canvas id="canvas"></canvas>

    <!-- === TOP BAR & CONTROLS === -->
    <!-- === TOP BAR & CONTROLS === -->
    <button id="info-toggle"
        style="position: absolute; top: 20px; left: 20px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; padding: 10px 16px; border-radius: 20px; cursor: pointer; backdrop-filter: blur(5px); z-index: 10; pointer-events: auto;">‚ÑπÔ∏è
        Replay Intro</button>

    <button id="btn-admin-toggle" class="btn" style="position: absolute; top: 20px; right: 20px; z-index: 10;">‚öôÔ∏è Manage
        Data</button>

    <a id="btn-magic-edit" class="btn"
        style="position: absolute; top: 60px; right: 20px; z-index: 10; color: #00E5FF; border-color: #00E5FF; text-decoration: none;"
        target="_blank">‚öôÔ∏è Edit Playlists</a>

    <script>
        document.getElementById('info-toggle').addEventListener('click', () => {
            // Restart Intro
            introStep = 0;
            document.getElementById('intro-layer').style.display = 'flex';
            document.getElementById('intro-layer').style.opacity = 1;
            nextIntroStep();
        });

        // Setup Magic Edit Button
        (function setupMagicEdit() {
            const btn = document.getElementById('btn-magic-edit');
            const hostname = window.location.hostname;
            if (hostname.includes('.github.io')) {
                const username = hostname.split('.')[0];
                const parts = window.location.pathname.split('/').filter(p => p.length > 0);
                const repo = parts.length > 0 ? parts[0] : '';
                btn.href = `https://github.com/${username}/${repo}/edit/main/playlists.txt`;
            } else {
                // Local or generic fallback
                btn.href = `https://github.com/munir-paviwala/musicForAll/edit/main/playlists.txt`;
                btn.title = 'Fallback to original repo for local dev';
            }
        })();
    </script>

    <!-- === JOURNEY PANEL === -->
    <div id="journey-panel">
        <button class="journey-btn" onclick="startRandomJourney()">üé≤ Guide Me Somewhere</button>
        <button class="journey-btn" onclick="startNeighborhoodJourney()">üèòÔ∏è Explore Neighborhood</button>
        <button id="auto-btn" class="journey-btn" onclick="toggleAutopilot()">‚ñ∂ Start Tour</button>
        <button id="skip-btn" class="journey-btn" onclick="forceNextSong()">‚è≠ Skip to Next</button>
        <button class="journey-btn" onclick="clearTrace()">üßπ Erase Trace</button>
        <button class="journey-btn" onclick="clearGuide()" id="clear-guide-btn"
            style="display:none; border-color: #ff4444; color: #ff8888;">‚ùå Stop Guide</button>
    </div>

    <!-- === ADMIN PANEL (From index.html) === -->
    <div id="admin-panel" class="pointer-events-auto">
        <div
            style="padding: 20px; border-bottom: 1px solid #30363d; display:flex; justify-content:space-between; align-items:center;">
            <h3 style="margin:0; color: white;">Library Manager</h3>
            <button id="btn-admin-close" class="btn" style="padding:5px 10px;">‚úï</button>
        </div>

        <div class="admin-content">
            <!-- THE PIPELINE -->
            <div class="admin-section">
                <span class="admin-label">1. Add Music</span>
                <p style="font-size: 0.85em; color: #8b949e; margin-bottom: 10px;">
                    This galaxy is built automatically. To add new playlists, open your repository on GitHub, edit
                    <code>playlists.txt</code>, and paste your YouTube playlist links. The automated bots will fetch the
                    songs and rebuild the map for you.
                </p>
            </div>

            <!-- STEP 2: CURATOR NOTES -->
            <div class="admin-section">
                <span class="admin-label">2. Curator Notes</span>
                <p style="font-size: 0.85em; color: #8b949e; margin-bottom: 10px;">
                    Add descriptions to your clusters for the placards.
                </p>
                <button id="btn-edit-notes" class="btn"
                    style="width:100%; margin-bottom:10px; border-color:#536DFE; color:#536DFE;">
                    üìù Edit Notes
                </button>
                <div id="notes-editor-container"
                    style="display:none; flex-direction:column; gap:10px; margin-bottom:10px; border: 1px solid #30363d; padding: 10px; border-radius: 6px; background: #000; max-height: 300px; overflow-y: auto;">
                    <!-- Dynamically populated textarea inputs -->
                </div>
            </div>

            <!-- STEP 3: SAVE -->
            <div class="admin-section">
                <span class="admin-label">3. Save Changes</span>
                <button id="btn-export" class="btn" style="width:100%;">üìã Copy 'data.json'</button>
                <p style="font-size: 0.8em; color: #8b949e; margin-top: 8px;">
                    Copy this and overwrite your local <code>data.json</code> file on GitHub to save permanently.
                </p>
                <textarea id="export-box" class="code-box" readonly style="height: 40px; opacity: 0.5;"></textarea>
            </div>

            <div class="admin-section" style="border-top: 1px solid #30363d; padding-top: 20px;">
                <button id="btn-clear-local" class="btn btn-danger" style="width:100%; font-size:0.8em;">‚ö†Ô∏è Reset Local
                    Changes</button>
            </div>
        </div>
    </div>

    <!-- === PLAYER UI === -->
    <div id="now-playing">
        <div id="np-title">Song Title</div>
        <div id="np-status" style="font-size: 0.8em; color: cyan; margin-bottom: 5px; display:none;">AUTOPILOT:
            LISTENING...</div>
        <div id="np-note" style="color:#aaa; font-style:italic; font-size:0.9em;"></div>
    </div>

    <div id="video-dock">
        <div id="yt-player-wrapper"></div>
    </div>

    <!-- === PLACARD UI === -->
    <div id="placard-overlay">
        <h2 id="placard-title">Cluster Title</h2>
        <p id="placard-desc">Cluster description goes here. It provides curatorial context about the songs in this
            neighborhood.</p>
    </div>

    <canvas id="canvas"></canvas>

    <script src="https://www.youtube.com/iframe_api"></script>

    <script>
        // ==========================================
        // 1. CONFIG & UTILS (From index.html)
        // ==========================================
        const SEED = typeof CONFIG !== 'undefined' ? CONFIG.galaxySeed : "MunirMusicGalaxy";
        const LOCAL_STORAGE_KEY = `music_galaxy_data_${SEED}`;
        const COLORS = [
            "#FF1744", "#F50057", "#D500F9", "#651FFF", "#2979F3", "#00B0FF",
            "#00E5FF", "#1DE9B6", "#00E676", "#76FF03", "#FFEA00", "#FFC400",
            "#FF9100", "#FF3D00", "#FF5252", "#FF80AB", "#E040FB", "#536DFE"
        ];

        // Seeded Random Utils
        let _seed = 1;
        function hashStr(str) {
            let h = 0x811c9dc5;
            for (let i = 0; i < str.length; i++) {
                h ^= str.charCodeAt(i);
                h = Math.imul(h, 0x01000193);
            }
            return h >>> 0;
        }
        function seedRandom(s) { _seed = hashStr(s); }
        function rand() {
            _seed = (_seed * 1664525 + 1013904223) % 4294967296;
            return _seed / 4294967296;
        }

        // ==========================================
        // 2. APP STATE
        // ==========================================
        let appState = {
            playlists: [],
            songs: [],
            anchors: [],
        };

        // Rendering State (From 22DecTry)
        let player = { x: 0, y: 0, size: 8 };
        let camera = { zoom: 1, targetZoom: 1 };
        let keys = {};
        let mouse = { x: 0, y: 0, dragging: false };
        let pathHistory = [];
        let guidePath = null;
        let guideTarget = null;
        let isAutopilot = false;
        let autopilotState = "IDLE";
        let autopilotIndex = 1;

        let currentPlacard = null; // Track currently displayed placard

        // ==========================================
        // 3. CLUSTERING ENGINE (From index.html)
        // ==========================================
        function runClusterSimulation() {
            console.log("‚ö° Running Optimization: Wide & Donut Clustering...");
            seedRandom(SEED);

            let playlists = appState.playlists;
            // Sort: Largest playlists first (Center-out galaxy strategy)
            let sortedIndices = playlists.map((p, i) => ({ i, count: p.songCount }))
                .sort((a, b) => b.count - a.count)
                .map(o => o.i);

            // 2. Calculate ideal radii (INCREASED SIZES)
            // Base radius 220 px
            let radii = playlists.map(p => 220 + (p.songCount / 50) * 450);

            let placed = [];
            let anchors = [];
            let pPositions = new Array(playlists.length).fill(null);

            sortedIndices.forEach((originalIndex, sortOrder) => {
                let p = playlists[originalIndex];
                let radius = radii[originalIndex];
                let x = 0, y = 0, found = false;

                if (sortOrder === 0) {
                    x = 0; y = 0; found = true;
                } else {
                    let attempt = 0;
                    let ringStart = 600; // Start searching further out (was 400)
                    while (!found && attempt < 2000) {
                        attempt++;
                        let searchDist = ringStart + (attempt * 5); // Expand faster
                        let angle = rand() * Math.PI * 2;
                        let tx = Math.cos(angle) * searchDist;
                        let ty = Math.sin(angle) * searchDist;

                        let overlaps = placed.some(exist => {
                            let dist = Math.hypot(tx - exist.x, ty - exist.y);
                            // HUGE PADDING: radius + exist.radius + 400px gap
                            return dist < (radius + exist.radius + 400);
                        });

                        if (!overlaps) {
                            x = tx; y = ty; found = true;
                        }
                    }
                }
                placed.push({ x, y, radius });

                let color = COLORS[originalIndex % COLORS.length];
                pPositions[originalIndex] = { x, y, radius };

                anchors.push({
                    id: p.id, name: p.name, x: Math.round(x), y: Math.round(y),
                    color: color, radius: Math.round(radius)
                });
            });

            // Place Songs
            appState.songs = []; // Rebuild flattened list
            playlists.forEach((p, idx) => {
                let center = pPositions[idx];
                if (!center) return;
                let songs = p.songs || [];
                let placedSongs = [];

                songs.forEach((song, sIdx) => {
                    let sx = center.x, sy = center.y;
                    let placedS = false;

                    // DONUT LOGIC: Minimum distance from center
                    let minR = 120; // 120px hole in center for label clarity
                    let maxR = center.radius * 1.1; // Allow slightly wider distribution

                    // Attempt random placement in donut
                    let sAttempt = 0;
                    while (!placedS && sAttempt < 300) {
                        sAttempt++;
                        let r = minR + Math.sqrt(rand()) * (maxR - minR);
                        let th = rand() * Math.PI * 2;
                        let tx = center.x + Math.cos(th) * r;
                        let ty = center.y + Math.sin(th) * r;
                        let claps = placedSongs.some(ps => Math.hypot(tx - ps.x, ty - ps.y) < 85);
                        if (!claps) { sx = tx; sy = ty; placedS = true; }
                    }

                    // SPIRAL FALLBACK (Aggressive)
                    // If random fails, spiral OUT from the existing cloud until we find a spot.
                    if (!placedS) {
                        let spiralAngle = 0;
                        let spiralDist = minR; // Start at donut inner edge
                        let spiralLimit = 0;

                        // Keep spiraling until spot found (Safety 5000: huge limit)
                        while (!placedS && spiralLimit < 5000) {
                            spiralLimit++;
                            spiralAngle += 0.3; // Tighter spiral for density
                            spiralDist += 2;    // Slow expansion

                            let tx = center.x + Math.cos(spiralAngle) * spiralDist;
                            let ty = center.y + Math.sin(spiralAngle) * spiralDist;

                            let claps = placedSongs.some(ps => Math.hypot(tx - ps.x, ty - ps.y) < 85);
                            if (!claps) {
                                sx = tx; sy = ty; placedS = true;
                                // If we pushed the boundary, expand the anchor visual
                                if (spiralDist > center.radius) center.radius = spiralDist;
                            }
                        }
                    }

                    // Critical Fix: If still failed (monitor size?), fallback to a random far spot instead of (0,0)
                    if (!placedS) {
                        let emergencyAngle = rand() * Math.PI * 2;
                        let emergencyDist = center.radius + 200;
                        sx = center.x + Math.cos(emergencyAngle) * emergencyDist;
                        sy = center.y + Math.sin(emergencyAngle) * emergencyDist;
                        // Just force it there, ignore overlaps to prevent stack overflow
                    }

                    // Enrich song object for renderer
                    song.x = Math.round(sx);
                    song.y = Math.round(sy);
                    song.offset = Math.round(rand() * 100);
                    song.color = anchors.find(a => a.id === p.id).color;

                    placedSongs.push({ x: sx, y: sy });
                    appState.songs.push(song);
                });

                // Refine Anchor Radius to match actaul spread
                let maxDist = 0;
                placedSongs.forEach(ps => {
                    let d = Math.hypot(ps.x - center.x, ps.y - center.y);
                    if (d > maxDist) maxDist = d;
                });
                let a = anchors.find(a => a.id === p.id);
                if (a) a.radius = Math.round(maxDist + 150);
            });

            appState.anchors = anchors;
            console.log(`‚úÖ Optimized Clustering: ${appState.songs.length} songs distributed widely.`);
            saveToLocalStorage();
        }

        // ==========================================
        // 4. DATA MANAGEMENT (From index.html)
        // ==========================================
        function loadData() {
            // Always fetch the freshest data from the server (bypassing browser cache)
            fetch('data.json?t=' + new Date().getTime())
                .then(r => r.json())
                .then(serverData => {
                    console.log("Loaded fresh data from server.");

                    // Check if the curator has unsaved local notes they are working on
                    let local = localStorage.getItem(LOCAL_STORAGE_KEY);
                    if (local) {
                        try {
                            let localData = JSON.parse(local);
                            // Overlay local notes onto the server's anchors
                            if (localData.anchors && serverData.anchors) {
                                serverData.anchors.forEach(sa => {
                                    let la = localData.anchors.find(a => a.id === sa.id);
                                    if (la && la.description) {
                                        sa.description = la.description;
                                    }
                                });
                            }
                        } catch (e) { console.error("Local notes corrupt", e); }
                    }
                    parseData(serverData);
                })
                .catch(e => {
                    console.warn("Failed to fetch server data, attempting local fallback...");
                    let local = localStorage.getItem(LOCAL_STORAGE_KEY);
                    if (local) {
                        try {
                            parseData(JSON.parse(local));
                        } catch (err) { }
                    }
                });
        }

        function parseData(data) {
            if (data.playlists) {
                appState.playlists = data.playlists;
                if (data.anchors) {
                    appState.anchors = data.anchors;

                    // Flatten songs if anchors exist (assume already clustered)
                    appState.songs = [];
                    appState.playlists.forEach(p => { if (p.songs) appState.songs.push(...p.songs); });
                } else {
                    // New data, needs clustering
                    runClusterSimulation();
                }
            }
            if (appState.songs.length === 0) {
                alert("No music found! Use the Manage panel to import seeded data.");
                document.getElementById('admin-panel').classList.add('open');
            } else if (appState.anchors && appState.anchors.length > 0) {
                // Randomly spawn the player at one of the cluster centers
                let randomAnchor = appState.anchors[Math.floor(Math.random() * appState.anchors.length)];
                player.x = randomAnchor.x;
                player.y = randomAnchor.y;
            }
        }

        function saveToLocalStorage() {
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify({
                playlists: appState.playlists,
                anchors: appState.anchors
            }));
        }

        // === ADMIN UI HANDLERS ===
        document.getElementById('btn-admin-toggle').onclick = () => document.getElementById('admin-panel').classList.toggle('open');
        document.getElementById('btn-admin-close').onclick = () => document.getElementById('admin-panel').classList.remove('open');

        // === ADMIN PANEL LOGIC ===

        // === ADMIN PANEL LOGIC ===

        // Handle btn-edit-notes
        document.getElementById('btn-edit-notes').onclick = () => {
            const container = document.getElementById('notes-editor-container');
            const btn = document.getElementById('btn-edit-notes');

            if (container.style.display === 'none') {
                container.style.display = 'flex';
                btn.innerText = "‚ùå Close Notes Editor";
                container.innerHTML = ""; // Clear existing

                if (!appState.anchors || appState.anchors.length === 0) {
                    container.innerHTML = "<span style='color:#ff8888;font-size:0.8em;'>No clusters available. Please import data first.</span>";
                    return;
                }

                appState.anchors.forEach((anchor, index) => {
                    let div = document.createElement('div');
                    let label = document.createElement('label');
                    label.innerText = anchor.name;
                    label.style.color = anchor.color || "#ccc";
                    label.style.fontSize = "0.85em";
                    label.style.fontWeight = "bold";

                    let textarea = document.createElement('textarea');
                    textarea.className = "code-box";
                    textarea.style.height = "60px";
                    textarea.style.marginTop = "5px";
                    textarea.style.color = "#fff";
                    textarea.placeholder = "Write curator notes here...";
                    textarea.value = anchor.description || "";

                    textarea.addEventListener('input', (e) => {
                        appState.anchors[index].description = e.target.value;
                        saveToLocalStorage(); // Auto-save locally
                    });

                    div.appendChild(label);
                    div.appendChild(textarea);
                    container.appendChild(div);
                });
            } else {
                container.style.display = 'none';
                btn.innerText = "üìù Edit Notes";
            }
        };

        document.getElementById('btn-export').onclick = () => {
            let exportData = { playlists: appState.playlists, anchors: appState.anchors };
            let str = JSON.stringify(exportData, null, 2);
            let box = document.getElementById('export-box');
            box.value = str; box.select(); document.execCommand('copy');
            alert("Copied to clipboard!");
        }

        let clearTimeoutHandle;
        document.getElementById('btn-clear-local').onclick = function () {
            const btn = this;
            if (btn.classList.contains('confirming')) {
                // Confirmed
                localStorage.removeItem(LOCAL_STORAGE_KEY);
                location.reload();
            } else {
                // First Click
                btn.classList.add('confirming');
                btn.innerText = "‚ö†Ô∏è Really Reset? Click again.";

                clearTimeoutHandle = setTimeout(() => {
                    btn.classList.remove('confirming');
                    btn.innerText = "‚ö†Ô∏è Reset Local Changes";
                }, 3000);
            }
        }

        // ==========================================
        // 5. JOURNEY & PATHFINDING (From 22DecTry)
        // ==========================================
        // ==========================================
        // 5. JOURNEY & PATHFINDING
        // ==========================================
        function startRandomJourney() {
            let songs = appState.songs;
            if (songs.length < 2) return alert("Need more songs!");

            // Look further for random songs due to large map
            let farSongs = songs.filter(s => Math.hypot(s.x - player.x, s.y - player.y) > 1500 && s.status !== 'error');
            let target = farSongs.length > 0 ? farSongs[Math.floor(Math.random() * farSongs.length)] : songs[Math.floor(Math.random() * songs.length)];
            guideTarget = target;

            // Widen the corridor for finding waypoints
            let waypoints = [];
            let vectorX = target.x - player.x;
            let vectorY = target.y - player.y;
            let totalDist = Math.hypot(vectorX, vectorY);

            songs.forEach(s => {
                if (s === target || s.status === 'error') return;
                let sx = s.x - player.x;
                let sy = s.y - player.y;
                let dot = (sx * vectorX + sy * vectorY) / (totalDist * totalDist);
                // Wider corridor (0.1-0.9 proj, < 400px from line)
                if (dot > 0.05 && dot < 0.95) {
                    let projX = player.x + dot * vectorX;
                    let projY = player.y + dot * vectorY;
                    if (Math.hypot(s.x - projX, s.y - projY) < 400) waypoints.push(s);
                }
            });
            waypoints.sort((a, b) => Math.hypot(a.x - player.x, a.y - player.y) - Math.hypot(b.x - player.x, b.y - player.y));

            // Sampling if too many
            if (waypoints.length > 15) {
                let sampled = [];
                for (let i = 0; i < 15; i++) sampled.push(waypoints[Math.floor(i * waypoints.length / 15)]);
                waypoints = sampled;
            }

            guidePath = [];
            // Do NOT add player pos as first point if using index 0 for next song
            guidePath.push(target); // Reversed? No, target is last.

            // Re-build path: Waypoints -> Target
            guidePath = [...waypoints, target];
            // If waypoints is empty, just go to target

            startJourneyUI();
        }

        function startNeighborhoodJourney() {
            let songs = appState.songs;
            let startSong;
            // Radius 2500 for large clusters
            let nearbySongs = songs.filter(s => Math.hypot(s.x - player.x, s.y - player.y) < 2500 && s.status !== 'error');

            if (nearbySongs.length > 0) {
                // Sort by distance to player to find true start
                nearbySongs.sort((a, b) => Math.hypot(a.x - player.x, a.y - player.y) - Math.hypot(b.x - player.x, b.y - player.y));
                startSong = nearbySongs[0];
            } else {
                startSong = songs.filter(s => s.status !== 'error')[Math.floor(Math.random() * songs.length)];
                player.x = startSong.x; player.y = startSong.y; // Teleport if lost
            }

            // Greedy Nearest Neighbor Path
            let path = [startSong];
            let visited = new Set([startSong]);
            let current = startSong;

            // Find up to 15 neighbors
            for (let i = 0; i < 15; i++) {
                let minDist = Infinity;
                let next = null;

                // Search unvisited within reasonable hop distance (e.g. 800px)
                songs.forEach(s => {
                    if (visited.has(s) || s.status === 'error') return;
                    let d = Math.hypot(s.x - current.x, s.y - current.y);
                    if (d < 1500 && d < minDist) {
                        minDist = d;
                        next = s;
                    }
                });

                if (next) {
                    path.push(next);
                    visited.add(next);
                    current = next;
                } else {
                    break; // No more close neighbors
                }
            }

            guidePath = path;
            startJourneyUI();
        }

        function startJourneyUI() {
            guideTarget = null;
            document.getElementById('clear-guide-btn').style.display = 'flex';
            document.getElementById('auto-btn').style.display = 'flex';
            document.getElementById('auto-btn').innerText = "‚è∏ Pause Tour";

            if (currentSongId) {
                // Already playing? Queue tour.
                isAutopilot = true; autopilotIndex = 0; autopilotState = "LISTENING";
                document.getElementById('np-status').style.display = "block";
                document.getElementById('np-status').innerText = "TOUR QUEUED: Waiting for current song...";
                document.getElementById('skip-btn').style.display = 'flex';
            } else {
                // Not playing. Move to first point.
                isAutopilot = true; autopilotIndex = 0; autopilotState = "MOVING";
                document.getElementById('skip-btn').style.display = 'flex';
                document.getElementById('np-status').style.display = "block";
                document.getElementById('np-status').innerText = "AUTOPILOT: MOVING TO START...";
            }
            camera.targetZoom = 0.6; // Slightly zoomed out for view
        }

        function toggleAutopilot() {
            if (!guidePath) return;
            isAutopilot = !isAutopilot;
            document.getElementById('auto-btn').innerText = isAutopilot ? "‚è∏ Pause Tour" : "‚ñ∂ Start Tour";
            if (isAutopilot) {
                if (currentSongId) {
                    autopilotState = "LISTENING";
                    document.getElementById('np-status').style.display = "block";
                    document.getElementById('np-status').innerText = "AUTOPILOT: LISTENING...";
                    document.getElementById('skip-btn').style.display = 'flex';
                } else { autopilotState = "MOVING"; }
                camera.targetZoom = 0.8;
            } else {
                document.getElementById('skip-btn').style.display = 'none';
                document.getElementById('np-status').style.display = 'none';
            }
        }

        function forceNextSong() {
            if (!isAutopilot) return;
            stopSong(); currentSongId = null; autopilotIndex++;
            if (autopilotIndex >= guidePath.length) { clearGuide(); }
            else {
                autopilotState = "MOVING";
                document.getElementById('skip-btn').style.display = 'flex';
                document.getElementById('np-status').innerText = "MOVING TO NEXT STOP...";
            }
        }

        function clearGuide() {
            guidePath = null; guideTarget = null; isAutopilot = false;
            document.getElementById('clear-guide-btn').style.display = 'none';
            document.getElementById('auto-btn').style.display = 'none';
            document.getElementById('skip-btn').style.display = 'none';
            document.getElementById('auto-btn').innerText = "‚ñ∂ Start Tour";
            document.getElementById('np-status').style.display = 'none';
        }
        function clearTrace() { pathHistory = []; }

        // ==========================================
        // 6. RENDERER (From 22DecTry)
        // ==========================================
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        window.addEventListener('resize', resize);
        function resize() {
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        }
        resize();

        let time = 0;
        function draw() {
            time += 0.04;

            // Autopilot Logic in Render Loop
            if (isAutopilot && guidePath && autopilotIndex < guidePath.length && autopilotState === "MOVING") {
                let target = guidePath[autopilotIndex];
                let dx = target.x - player.x; let dy = target.y - player.y;
                let dist = Math.sqrt(dx * dx + dy * dy);

                let isTargetSong = appState.songs.find(s => Math.abs(s.x - target.x) < 1 && Math.abs(s.y - target.y) < 1);
                if (dist < 10) {
                    if (isTargetSong) {
                        if (isTargetSong.status === 'error') {
                            autopilotIndex++;
                        } else {
                            autopilotState = "LISTENING";
                            document.getElementById('np-status').style.display = "block";
                            document.getElementById('np-status').innerText = "AUTOPILOT: LISTENING...";
                            document.getElementById('skip-btn').style.display = 'flex';
                        }
                    } else {
                        autopilotIndex++;
                        if (autopilotIndex >= guidePath.length) clearGuide();
                    }
                } else {
                    let moveSpeed = 4.0 / camera.zoom;
                    player.x += (dx / dist) * moveSpeed; player.y += (dy / dist) * moveSpeed;
                }
            } else if (!isAutopilot) {
                if (keys['w']) player.y -= 6 / camera.zoom; if (keys['s']) player.y += 6 / camera.zoom;
                if (keys['a']) player.x -= 6 / camera.zoom; if (keys['d']) player.x += 6 / camera.zoom;
            }

            camera.zoom += (camera.targetZoom - camera.zoom) * 0.1;
            if (pathHistory.length === 0 || Math.abs(player.x - pathHistory[pathHistory.length - 1].x) > 10 || Math.abs(player.y - pathHistory[pathHistory.length - 1].y) > 10) {
                pathHistory.push({ x: player.x, y: player.y });
            }

            // Canvas Clear & Setup
            ctx.fillStyle = "#000"; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save(); ctx.translate(canvas.width / 2, canvas.height / 2); ctx.scale(camera.zoom, camera.zoom); ctx.translate(-player.x, -player.y);

            // Draw Anchors (Galaxy centers)
            ctx.globalCompositeOperation = "lighter";
            let closestAnchor = null;
            let closestAnchorDist = Infinity;

            appState.anchors.forEach((a, i) => {
                // Original subtle radial glow
                let grad = ctx.createRadialGradient(a.x, a.y, 0, a.x, a.y, a.radius);
                grad.addColorStop(0, a.color);
                grad.addColorStop(1, "rgba(0,0,0,0)");
                ctx.fillStyle = grad;
                ctx.globalAlpha = 0.8; // Slightly softer than before to keep focus on songs
                ctx.beginPath();
                ctx.arc(a.x, a.y, a.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;

                // Check distance to player for placard (using true un-transformed coordinates)
                let distToAnchor = Math.hypot(player.x - a.x, player.y - a.y);
                if (distToAnchor < a.radius * 0.4 && distToAnchor < closestAnchorDist) {
                    closestAnchor = a;
                    closestAnchorDist = distToAnchor;
                }
            });
            ctx.globalCompositeOperation = "source-over";

            // Update Placard UI
            const placardEl = document.getElementById('placard-overlay');
            if (closestAnchor && closestAnchor.description) {
                if (currentPlacard !== closestAnchor.id) {
                    currentPlacard = closestAnchor.id;
                    document.getElementById('placard-title').innerText = closestAnchor.name;
                    document.getElementById('placard-desc').innerText = closestAnchor.description;
                    placardEl.classList.add('visible');
                }
            } else {
                if (currentPlacard !== null) {
                    currentPlacard = null;
                    placardEl.classList.remove('visible');
                }
            }

            // Trace
            if (pathHistory.length > 1) {
                ctx.strokeStyle = "rgba(255, 255, 255, 0.15)"; ctx.lineWidth = 2; ctx.beginPath();
                ctx.moveTo(pathHistory[0].x, pathHistory[0].y);
                for (let i = 1; i < pathHistory.length; i++) ctx.lineTo(pathHistory[i].x, pathHistory[i].y);
                ctx.stroke();
            }

            // Guide Line
            if (guidePath && guidePath.length > 1) {
                ctx.strokeStyle = isAutopilot ? "rgba(0, 255, 255, 0.8)" : "rgba(0, 255, 255, 0.4)";
                ctx.lineWidth = 3; ctx.setLineDash([15, 10]); ctx.beginPath();
                let startIdx = autopilotIndex > 0 ? autopilotIndex - 1 : 0;
                ctx.moveTo(player.x, player.y);
                for (let i = autopilotIndex; i < guidePath.length; i++) ctx.lineTo(guidePath[i].x, guidePath[i].y);
                ctx.stroke(); ctx.setLineDash([]);

                for (let i = autopilotIndex; i < guidePath.length; i++) {
                    let pt = guidePath[i];
                    if (appState.songs.some(s => Math.abs(s.x - pt.x) < 1 && Math.abs(s.y - pt.y) < 1)) {
                        ctx.fillStyle = "cyan"; ctx.beginPath(); ctx.arc(pt.x, pt.y, 6, 0, Math.PI * 2); ctx.fill();
                    }
                }
            }

            // Draw Songs
            let touching = false;
            let viewW = canvas.width / camera.zoom;
            let viewH = canvas.height / camera.zoom;

            appState.songs.forEach(s => {
                // Culling
                if (Math.abs(s.x - player.x) > viewW && Math.abs(s.y - player.y) > viewH) return;

                let floatY = s.y + Math.sin(time + s.offset) * 6;
                let dist = Math.sqrt((player.x - s.x) ** 2 + (player.y - floatY) ** 2);
                let isTouching = dist < (35 + player.size);
                let r = isTouching ? 50 : 35;

                // Styles
                if (s.status === 'error') { ctx.strokeStyle = "#ff0000"; ctx.lineWidth = 2; }
                else if (guidePath && guidePath.some(pt => Math.abs(pt.x - s.x) < 1 && Math.abs(pt.y - s.y) < 1)) { ctx.strokeStyle = "cyan"; ctx.lineWidth = 3; }
                else { ctx.strokeStyle = "rgba(255,255,255,0.4)"; ctx.lineWidth = 1.5; }

                ctx.beginPath(); ctx.arc(s.x, floatY, r, 0, Math.PI * 2);
                if (isTouching) {
                    touching = true;
                    ctx.shadowBlur = 30; ctx.shadowColor = s.status === 'error' ? "red" : "white";
                    ctx.fillStyle = s.status === 'error' ? "#330000" : "white"; ctx.fill(); ctx.shadowBlur = 0;
                    if (currentSongId !== s.ytId) { playSong(s); currentSongId = s.ytId; }
                } else { ctx.fillStyle = "rgba(255,255,255,0.05)"; ctx.fill(); ctx.stroke(); }

                // Text
                if (camera.zoom > 0.5) {
                    ctx.fillStyle = isTouching ? (s.status === 'error' ? "red" : "black") : "rgba(255,255,255,0.7)";
                    ctx.font = isTouching ? "bold 12px Arial" : "11px Arial";
                    ctx.textAlign = "center"; ctx.fillText(s.title, s.x, floatY + r + 15);
                }
            });

            if (!touching && currentSongId && !isAutopilot) { stopSong(); currentSongId = null; }

            // Player & Fog
            if (playerImg && playerImg.complete && playerImg.naturalWidth !== 0) {
                // Draw Sprite
                let size = player.size * 5; // Good size for pixel art
                ctx.imageSmoothingEnabled = false; // Keep pixels sharp
                ctx.drawImage(playerImg, player.x - size / 2, player.y - size / 2, size, size);
            } else {
                ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2); ctx.fill();
            }

            ctx.restore();
        }

        // 7. INPUT HANDLERS
        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (isAutopilot && (e.key === 'w' || e.key === 'a' || e.key === 's' || e.key === 'd')) toggleAutopilot();
        });
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        window.addEventListener('wheel', e => { e.preventDefault(); camera.targetZoom = Math.max(0.2, Math.min(3.0, camera.targetZoom - e.deltaY * 0.001)); }, { passive: false });

        function toWorld(sx, sy) { const cx = canvas.width / 2; const cy = canvas.height / 2; return { x: (sx - cx) / camera.zoom + player.x, y: (sy - cy) / camera.zoom + player.y }; }

        function handlePointerDown(x, y) {
            mouse.dragging = true; mouse.x = x; mouse.y = y;
            if (isAutopilot) toggleAutopilot();
        }
        function handlePointerMove(x, y) {
            const dx = x - mouse.x; const dy = y - mouse.y; mouse.x = x; mouse.y = y;
            if (mouse.dragging) { player.x -= dx / camera.zoom; player.y -= dy / camera.zoom; }
        }
        function handlePointerUp() { mouse.dragging = false; }

        canvas.addEventListener('mousedown', e => handlePointerDown(e.clientX, e.clientY));
        window.addEventListener('mouseup', handlePointerUp);
        canvas.addEventListener('mousemove', e => handlePointerMove(e.clientX, e.clientY));

        // Touch
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            if (e.touches.length > 0) handlePointerDown(e.touches[0].clientX, e.touches[0].clientY);
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                mouse.pinchDistance = Math.sqrt(dx * dx + dy * dy);
            }
        }, { passive: false });

        window.addEventListener('touchend', e => {
            handlePointerUp();
            mouse.pinchDistance = null;
        }, { passive: false });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (e.touches.length === 2 && mouse.pinchDistance !== null) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const newPinchDistance = Math.sqrt(dx * dx + dy * dy);
                camera.targetZoom = Math.max(0.2, Math.min(3.0, camera.targetZoom * (newPinchDistance / mouse.pinchDistance)));
                mouse.pinchDistance = newPinchDistance;
            } else if (e.touches.length === 1) {
                handlePointerMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });


        // ==========================================
        // 8. PLAYER & INIT
        // ==========================================
        let playerInstance = null;
        let currentSongId = null;

        function onYouTubeIframeAPIReady() {
            playerInstance = new YT.Player('yt-player-wrapper', {
                height: '100%',
                width: '100%',
                videoId: '',
                host: 'https://www.youtube.com', // Force SSL
                playerVars: {
                    'playsinline': 1,
                    'controls': 1,
                    'disablekb': 1,
                    'origin': window.location.origin, // Critical for localhost
                    'rel': 0
                },
                events: { 'onStateChange': onPlayerStateChange, 'onError': onPlayerError }
            });
        }
        function onPlayerStateChange(event) {
            if (event.data === 0 && isAutopilot && autopilotState === "LISTENING") forceNextSong();
        }
        function onPlayerError(event) {
            console.warn("Song Unavailable. Code:", event.data);
            let song = appState.songs.find(s => s.ytId === currentSongId);
            if (song) {
                song.status = 'error';
                document.getElementById('np-title').innerText = "SONG UNAVAILABLE";
                document.getElementById('np-note').innerText = "Skipping automatically...";
            }
            if (isAutopilot) setTimeout(() => forceNextSong(), 1500);
        }

        function playSong(song) {
            if (!playerInstance || !playerInstance.loadVideoById) return;
            if (song.status === 'error') return;
            document.getElementById('video-dock').style.display = "block";
            playerInstance.loadVideoById(song.ytId);
            document.getElementById('np-title').innerText = song.title;
            document.getElementById('np-note').innerText = song.note || "";
            document.getElementById('now-playing').style.display = "block";
        }

        function stopSong() {
            if (playerInstance && playerInstance.stopVideo) playerInstance.stopVideo();
            document.getElementById('video-dock').style.display = "none";
            document.getElementById('now-playing').style.display = "none";
        }

        // ==========================================
        // 9. GAMIFIED INTRO LOGIC
        // ==========================================
        const introText = document.getElementById('dialogue-text');
        const nextArrow = document.getElementById('next-arrow');
        const actionBox = document.getElementById('intro-actions');
        const guideChar = document.getElementById('guide-char');

        // Character Sprite
        // We will look for a local file first.
        let userAvatar = 'assets/avatar.gif';
        let playerImg = new Image();
        playerImg.src = userAvatar;
        // Fallback or verify load
        playerImg.onerror = () => {
            // If local fails, maybe use a placeholder or just keep circle
            console.log("Custom avatar not found, using default circle");
            playerImg = null;
        };

        // Initial intro setup
        guideChar.style.backgroundImage = `url('${userAvatar}')`;

        let introStep = 0;
        const steps = [
            {
                text: typeof CONFIG !== 'undefined' ? CONFIG.introText : "Hello there! Welcome to my MUSICAL GALAXY!\n\nI am Munir. \n\nI am your guide in this neighborhood.",
                pose: "bounce"
            },
            {
                text: "This world is inhabited by bubbles called... SONGS.\n\nThey float around in clusters. \n\nWalk up to them to hear them!",
                pose: "normal"
            },
            {
                text: "NAVIGATING IS EASY!\n\nUse [W, A, S, D] to move your character.\nUse your Mouse to drag the camera view.\n\nDragging also moves you on Touch Screens!",
                pose: "normal"
            },
            {
                text: "Want to make your own version of this app?\n\nCheck out the GitHub repo! You can fork it and use your own data.",
                action: "repo_link"
            },
            {
                text: "Alright! Your journey is about to begin.\n\nYou will spawn at a random location in the map.\n\nEnjoy exploring the musical galaxy!",
                action: "start_choice"
            }
        ];

        // Credits Logic
        async function showCredits() {
            console.log("Attempting to load credits...");
            try {
                const response = await fetch('assets/credits.txt');
                console.log("Fetch response:", response.status);
                if (!response.ok) throw new Error("File not found");

                const text = await response.text();
                document.getElementById('credits-content').innerText = text;
                document.getElementById('credits-modal').style.display = 'flex';
            } catch (e) {
                console.error("Credits Load Error:", e);
                document.getElementById('credits-content').innerText = "Could not load 'assets/credits.txt'.\nCheck console for details.\n" + e.message;
                document.getElementById('credits-modal').style.display = 'flex';
            }
        }

        function closeCredits() {
            document.getElementById('credits-modal').style.display = 'none';
        }


        let typingInterval;
        let isTyping = false;
        let currentFullText = "";

        function typeText(text, callback) {
            // Reset State
            clearInterval(typingInterval);
            introText.innerHTML = "";
            nextArrow.style.display = "none";
            actionBox.style.display = "none";
            isTyping = true;
            currentFullText = text;

            let i = 0;
            typingInterval = setInterval(() => {
                introText.innerHTML += text.charAt(i);
                i++;
                if (i >= text.length) {
                    clearInterval(typingInterval);
                    isTyping = false;
                    if (callback) callback();
                    else nextArrow.style.display = "block";
                }
            }, 30); // Typing speed
        }

        function finishTypingNow() {
            clearInterval(typingInterval);
            introText.innerHTML = currentFullText;
            isTyping = false;

            // Check if there was a callback action needed
            let s = steps[introStep - 1]; // Current step
            if (s && s.action === "repo_link") {
                nextArrow.style.display = "block";
            } else if (s && s.action === "start_choice") {
                showActions("LET'S GO!", null, () => endIntro(), null);
            } else {
                nextArrow.style.display = "block";
            }
        }

        function nextIntroStep() {
            if (introStep >= steps.length) {
                endIntro();
                return;
            }

            let s = steps[introStep];
            introStep++;

            typeText(s.text, () => {
                // Action Logic (Callback when typing done normally)
                if (s.action === "repo_link") {
                    nextArrow.style.display = "block";
                } else if (s.action === "start_choice") {
                    showActions("LET'S GO!", null, () => endIntro(), null);
                } else {
                    nextArrow.style.display = "block";
                }
            });
        }

        function showActions(label1, label2, cb1, cb2) {
            actionBox.style.display = "flex";
            let b1 = document.getElementById('act-btn-1');
            let b2 = document.getElementById('act-btn-2');
            b1.innerText = label1; b1.onclick = cb1;

            if (label2) {
                b2.style.display = "inline-block";
                b2.innerText = label2; b2.onclick = cb2;
            } else {
                b2.style.display = "none";
            }
        }

        // Space/Enter Support for Intro
        document.addEventListener('keydown', (e) => {
            const introLayer = document.getElementById('intro-layer');
            if (introLayer.style.display !== 'none' && introLayer.style.opacity !== '0') {
                if (e.key === ' ' || e.key === 'Enter') {
                    e.preventDefault(); // Prevent scrolling

                    if (isTyping) {
                        // Case 1: Currently Typing -> Finish Immediately
                        finishTypingNow();
                    } else {
                        // Case 2: Waiting -> Next Step
                        // If arrow visible OR if we are at start button
                        if (nextArrow.style.display === 'block') {
                            nextIntroStep();
                        } else if (document.getElementById('intro-actions').style.display === 'flex') {
                            if (document.getElementById('act-btn-2').style.display === 'none') {
                                document.getElementById('act-btn-1').click();
                            }
                        }
                    }
                }
            }
        });

        // Handle Avatar Upload
        document.getElementById('avatar-upload').addEventListener('change', (e) => {
            let file = e.target.files[0];
            if (file) {
                let reader = new FileReader();
                reader.onload = (evt) => {
                    userAvatar = evt.target.result;
                    // Update Guide Char to show preview
                    guideChar.style.backgroundImage = `url('${userAvatar}')`;
                    guideChar.style.height = "64px"; // Pixel art size
                    guideChar.style.width = "64px";
                    player.size = 15; // Make player bigger for sprite
                    // We need to modify render to draw image instead of circle logic later
                    // For now, proceed
                    nextArrow.style.display = "block";
                };
                reader.readAsDataURL(file);
            }
        });

        function endIntro() {
            document.getElementById('intro-layer').style.opacity = 0;
            setTimeout(() => {
                document.getElementById('intro-layer').style.display = 'none';
                // Start Audio context
                if (playerInstance && playerInstance.playVideo) {
                    playerInstance.playVideo();
                    setTimeout(() => playerInstance.pauseVideo(), 500);
                }
                loadData();
            }, 500);
        }

        // Start the Intro
        setTimeout(nextIntroStep, 500);

        // START LOOP
        setInterval(draw, 16);

    </script>
</body>

</html>